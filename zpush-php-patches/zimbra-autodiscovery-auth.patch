--- zimbra74/zimbra.php.orig	2025-09-09 11:09:23.290431161 -0700
+++ zimbra74/zimbra.php	2025-09-09 11:20:03.443552497 -0700
@@ -1056,6 +1056,10 @@
         $this->_domain = $domain;
 //        $this->_password = $password;    // Fix to replace symbols in user passwords.
         $this->_password = str_replace(array("&", "\"", ">", "<" ), array("&amp;", "&quot;", "&gt;", "&lt;" ), $password);
+        // Keep a raw copy of the supplied secret for AutoDiscover Basic validation (protocol=zsync).
+        // - The sanitized $this->_password is used only inside the SOAP XML body below.
+        // - AutoDiscover uses HTTP Basic auth and must receive the raw, unescaped password.
+        $passwordRaw = $password;
         $this->_addresses = array();
 
 
@@ -1135,6 +1139,100 @@
             $skip_soap_auth = false;
         }
         
+        /**
+         * Optional: AutoDiscover (zsync) + SOAP <preauth> authentication path (no shim required)
+         * -------------------------------------------------------------------------------------
+         * Why this exists:
+         * - With 2FA enabled, Zimbra only accepts application-specific passwords for non-interactive
+         *   protocols (imap, pop3, dav, zsync). SOAP is an interactive protocol and rejects app passwords
+         *   by design when 2FA is enabled.
+         * - AutoDiscover authenticates with HTTP Basic under protocol=zsync, which accepts app passwords
+         *   (and also primary passwords when 2FA is OFF). We can leverage it to validate the user secret
+         *   regardless of whether it is a primary or an app password.
+         * - After credentials are accepted by AutoDiscover (any HTTP status that is not 401), we obtain a
+         *   mailbox token via SOAP AuthRequest using <preauth>, which does not require the user password.
+         *
+         * How to enable (in backend zimbra config.php):
+         * - define('ZIMBRA_AUTODISCOVER_AUTH', true);
+         * - define('ZIMBRA_PREAUTH_KEY', 'hex value from: zmprov gdpak your-domain.com');
+         *   Notes about the preauth key:
+         *     - It is a per-domain secret (hex string) used to compute the HMAC for <preauth>.
+         *     - Handle it like a credential: store securely and rotate as appropriate.
+         *
+         * Behavior details:
+         * - We POST to /Autodiscover/Autodiscover.xml with Basic user:password and a minimal XML body that
+         *   includes the email address. Authentication occurs before response-schema handling.
+         * - Any non-401 response means credentials were accepted under zsync; servers may return 200/403/503
+         *   depending on features or schema support.
+         * - On acceptance, we compute the preauth HMAC: HMAC-SHA1 of "account|by|expires|timestamp" using the
+         *   domain preauth key (the hex string from zmprov gdpak, used as-is as the HMAC key) and send a SOAP
+         *   AuthRequest with <preauth>. On success, we skip the password-based SOAP login.
+         * - If AutoDiscover returns 401 or preauth fails, execution falls back to the existing password-based
+         *   SOAP AuthRequest below.
+         */
+        if (defined('ZIMBRA_AUTODISCOVER_AUTH') && ($this->ToBool(ZIMBRA_AUTODISCOVER_AUTH) === true)
+            && defined('ZIMBRA_PREAUTH_KEY') && ZIMBRA_PREAUTH_KEY) {
+            $adUrl = rtrim($this->_publicURL, '/').'/Autodiscover/Autodiscover.xml';
+            // Request Outlook schema (commonly present). Authentication happens before schema handling.
+            $adBody = '<?xml version="1.0" encoding="utf-8"?>'
+                    . '<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/mobilesync/requestschema/2006">'
+                    . '  <Request>'
+                    . '    <EMailAddress>'.$this->_username.'</EMailAddress>'
+                    . '    <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>'
+                    . '  </Request>'
+                    . '</Autodiscover>';
+            $adAuth = base64_encode($this->_username.':'.$passwordRaw);
+            $adCh = curl_init();
+            curl_setopt($adCh, CURLOPT_URL, $adUrl);
+            curl_setopt($adCh, CURLOPT_POST, true);
+            curl_setopt($adCh, CURLOPT_POSTFIELDS, $adBody);
+            curl_setopt($adCh, CURLOPT_RETURNTRANSFER, true);
+            curl_setopt($adCh, CURLOPT_HEADER, false);
+            curl_setopt($adCh, CURLOPT_SSL_VERIFYPEER, $this->_sslVerifyPeer);
+            curl_setopt($adCh, CURLOPT_SSL_VERIFYHOST, $this->_sslVerifyHost);
+            curl_setopt($adCh, CURLOPT_CONNECTTIMEOUT, 10);
+            curl_setopt($adCh, CURLOPT_TIMEOUT, 15);
+            curl_setopt($adCh, CURLOPT_HTTPHEADER, array(
+                'Authorization: Basic '.$adAuth,
+                'Content-Type: text/xml; charset=UTF-8',
+                'User-Agent: Z-Push-AutoDiscover'
+            ));
+            $adResp = curl_exec($adCh);
+            $adCode = curl_getinfo($adCh, CURLINFO_HTTP_CODE);
+            if ($adResp === false) {
+                ZLog::Write(LOGLEVEL_DEBUG, 'Zimbra->Logon(): AutoDiscover request error: '.curl_error($adCh));
+            } else {
+                ZLog::Write(LOGLEVEL_DEBUG, 'Zimbra->Logon(): AutoDiscover HTTP '.$adCode.' for '.$this->_username);
+            }
+            curl_close($adCh);
+
+            // Any non-401 implies credentials accepted under zsync; proceed to <preauth>
+            if ($adCode != 401) {
+                // Compose preauth HMAC per Zimbra docs: data = account|by|expires|timestamp (by=name, expires=0)
+                $tsMs = (string) round(microtime(true) * 1000);
+                $preauthData = $this->_username.'|name|0|'.$tsMs;
+                // The preauth key is the hex string returned by `zmprov gdpak <domain>`; used as-is as HMAC key.
+                $preauthHex = hash_hmac('sha1', $preauthData, ZIMBRA_PREAUTH_KEY);
+
+                $body    = '<AuthRequest xmlns="urn:zimbraAccount">'
+                         . '  <account by="name">'.$this->_username.'</account>'
+                         . '  <preauth timestamp="'.$tsMs.'" expires="0">'.$preauthHex.'</preauth>'
+                         . '  <attrs><attr name="uid"/></attrs>'
+                         . '  <prefs><pref name="zimbraPrefTimeZoneId"/></prefs>'
+                         . '</AuthRequest>';
+
+                $response = $this->SoapRequest($body, $header, true, $returnJSON);
+                if ($response) {
+                    ZLog::Write(LOGLEVEL_DEBUG, 'Zimbra->Logon(): Preauth via SOAP succeeded after AutoDiscover validation');
+                    $skip_soap_auth = true; // Skip password-based SOAP login
+                } else {
+                    ZLog::Write(LOGLEVEL_DEBUG, 'Zimbra->Logon(): Preauth via SOAP failed, will fall back to SOAP password login');
+                }
+            } else {
+                ZLog::Write(LOGLEVEL_DEBUG, 'Zimbra->Logon(): AutoDiscover validation returned 401 (invalid credentials)');
+            }
+        }
+
         if (!$skip_soap_auth) {
             $body    = '<AuthRequest xmlns="urn:zimbraAccount">
                             <account by="name">'.$this->_username.'</account>
